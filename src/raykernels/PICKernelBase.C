//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html
#include "PICKernelBase.h"

registerMooseObject("SalamanderApp", PICKernelBase);

InputParameters
PICKernelBase::validParams()
{
  InputParameters params = GeneralRayKernel::validParams();
  params.addClassDescription("Basic kernel which simply updates the starting direction and maximum "
                             "distance of each ray on the start of each time step");
  return params;
}

PICKernelBase::PICKernelBase(const InputParameters & params)
  : GeneralRayKernel(params),
    _v_x_index(_study.getRayDataIndex("v_x")),
    _v_y_index(_study.getRayDataIndex("v_y")),
    _v_z_index(_study.getRayDataIndex("v_z")),
    _direction_set_index(_study.getRayDataIndex("direction_set"))
{
}

void
PICKernelBase::preTrace()
{
  auto dt = _fe_problem.dt();
  setDirectionAndMaxDistance(dt);
}

void
PICKernelBase::setDirectionAndMaxDistance(const Real dt)
{
  // lets make sure we don't keep trying to set the starting direction
  // if it has already been set when the ray is passed between processors.
  if (currentRay()->data()[_direction_set_index])
    return;
  currentRay()->data()[_direction_set_index] = true;

  auto ray = currentRay();
  Point v = Point(ray->data()[_v_x_index], ray->data()[_v_y_index], ray->data()[_v_z_index]);
  libMesh::Point velocity = Point(0, 0, 0);
  // calculating max distance for the correct problem dimention
  auto dim = _fe_problem.mesh().dimension();

  if (dim >= 1)
    velocity(0) = v(0);

  if (dim >= 2)
    velocity(1) = v(1);

  if (dim == 3)
    velocity(2) = v(2);

  const auto max_dist = std::sqrt(velocity * velocity) * dt;
  const auto direction = velocity.unit();

  ray->setStartingMaxDistance(max_dist);
  ray->setStartingDirection(direction);
}

void
PICKernelBase::onSegment()
{
}

void
PICKernelBase::postTrace()
{
}
